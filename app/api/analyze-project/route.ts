import { type NextRequest, NextResponse } from "next/server"
import JSZip from "jszip"

interface ProjectInfo {
  websiteUrl: string
  businessName: string
  description: string
  targetKeywords: string[]
  industry: string
  targetAudience: string
  location: string
  competitors: string[]
}

interface ProjectAnalysis {
  projectType: "html" | "react" | "nextjs" | "mixed"
  framework: string
  totalFiles: number
  pageFiles: FileAnalysis[]
  componentFiles: FileAnalysis[]
  staticFiles: FileAnalysis[]
  hasRouting: boolean
  hasMetadata: boolean
  seoReadiness: number
}

interface FileAnalysis {
  filename: string
  path: string
  type: "html" | "jsx" | "tsx" | "js" | "ts" | "css" | "other"
  size: number
  isPage: boolean
  isComponent: boolean
  needsSEO: boolean
  currentSEO: {
    hasTitle: boolean
    hasDescription: boolean
    hasKeywords: boolean
    hasOpenGraph: boolean
    hasStructuredData: boolean
  }
  seoCode: {
    metadata?: string
    htmlHead?: string
    structuredData?: string
  }
  issues: string[]
  recommendations: string[]
  seoScore: number
}

function detectProjectType(files: { [key: string]: JSZip.JSZipObject }): {
  projectType: ProjectAnalysis["projectType"]
  framework: string
} {
  const fileNames = Object.keys(files)

  // Check for Next.js
  if (fileNames.some((name) => name.includes("next.config") || name.includes("app/") || name.includes("pages/"))) {
    return { projectType: "nextjs", framework: "Next.js" }
  }

  // Check for React
  if (
    fileNames.some((name) => name.endsWith(".jsx") || name.endsWith(".tsx")) ||
    fileNames.some((name) => name.includes("package.json"))
  ) {
    return { projectType: "react", framework: "React" }
  }

  // Check for HTML
  if (fileNames.some((name) => name.endsWith(".html"))) {
    return { projectType: "html", framework: "HTML/CSS/JS" }
  }

  return { projectType: "mixed", framework: "Mixed" }
}

function getFileType(filename: string): FileAnalysis["type"] {
  const ext = filename.split(".").pop()?.toLowerCase()
  switch (ext) {
    case "html":
    case "htm":
      return "html"
    case "jsx":
      return "jsx"
    case "tsx":
      return "tsx"
    case "js":
      return "js"
    case "ts":
      return "ts"
    case "css":
      return "css"
    default:
      return "other"
  }
}

function isPageFile(filename: string, projectType: string): boolean {
  const name = filename.toLowerCase()

  if (projectType === "html") {
    return name.endsWith(".html")
  }

  if (projectType === "nextjs") {
    return (
      name.includes("/page.") ||
      name.includes("/layout.") ||
      name.includes("pages/") ||
      name === "index.jsx" ||
      name === "index.tsx"
    )
  }

  if (projectType === "react") {
    return name.includes("app.") || name.includes("index.") || name.includes("home.") || name.includes("main.")
  }

  return false
}

function analyzeCurrentSEO(content: string, fileType: string) {
  const currentSEO = {
    hasTitle: false,
    hasDescription: false,
    hasKeywords: false,
    hasOpenGraph: false,
    hasStructuredData: false,
  }

  if (fileType === "html") {
    currentSEO.hasTitle = content.includes("<title>") && !content.includes("<title></title>")
    currentSEO.hasDescription = content.includes('name="description"')
    currentSEO.hasKeywords = content.includes('name="keywords"')
    currentSEO.hasOpenGraph = content.includes('property="og:')
    currentSEO.hasStructuredData = content.includes("application/ld+json")
  } else if (fileType === "jsx" || fileType === "tsx") {
    currentSEO.hasTitle = content.includes("title:") || content.includes("<title>")
    currentSEO.hasDescription = content.includes("description:") || content.includes('name="description"')
    currentSEO.hasKeywords = content.includes("keywords:") || content.includes('name="keywords"')
    currentSEO.hasOpenGraph = content.includes("openGraph:") || content.includes('property="og:')
    currentSEO.hasStructuredData = content.includes("application/ld+json") || content.includes("structuredData")
  }

  return currentSEO
}

function generateSEOCode(
  file: FileAnalysis,
  projectInfo: ProjectInfo,
): {
  metadata?: string
  htmlHead?: string
  structuredData?: string
} {
  const businessName = projectInfo.businessName
  const description = projectInfo.description
  const keywords = projectInfo.targetKeywords
  const websiteUrl = projectInfo.websiteUrl
  const pageName = file.filename.replace(/\.(html|jsx|tsx|js|ts)$/, "")
  const primaryKeyword = keywords.length > 0 ? keywords[0] : pageName

  if (file.type === "html") {
    const htmlHead = `<!-- SEO Meta Tags - Generated by AxoraWeb SEO Code Generator -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${primaryKeyword} | ${businessName} - ${description.substring(0, 50)}...</title>
<meta name="description" content="${description.substring(0, 155)}... | ${businessName}">
<meta name="keywords" content="${keywords.join(", ")}">
<meta name="author" content="${businessName}">
<link rel="canonical" href="${websiteUrl}/${pageName}">

<!-- Open Graph Tags -->
<meta property="og:title" content="${primaryKeyword} | ${businessName}">
<meta property="og:description" content="${description.substring(0, 155)}...">
<meta property="og:type" content="website">
<meta property="og:url" content="${websiteUrl}/${pageName}">
<meta property="og:image" content="${websiteUrl}/og-image.jpg">
<meta property="og:site_name" content="${businessName}">

<!-- Twitter Card Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="${primaryKeyword} | ${businessName}">
<meta name="twitter:description" content="${description.substring(0, 155)}...">
<meta name="twitter:image" content="${websiteUrl}/twitter-image.jpg">`

    const structuredData = `<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "${primaryKeyword} | ${businessName}",
  "description": "${description}",
  "url": "${websiteUrl}/${pageName}",
  "mainEntity": {
    "@type": "Organization",
    "name": "${businessName}",
    "url": "${websiteUrl}",
    "description": "${description}",
    "keywords": "${keywords.join(", ")}"
  }
}
</script>`

    return { htmlHead, structuredData }
  }

  if (file.type === "tsx") {
    const metadata = `// SEO Metadata - Generated by AxoraWeb SEO Code Generator
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: '${primaryKeyword} | ${businessName}',
  description: '${description.substring(0, 155)}... | ${businessName}',
  keywords: [${keywords.map((k) => `'${k}'`).join(", ")}],
  authors: [{ name: '${businessName}', url: '${websiteUrl}' }],
  creator: '${businessName}',
  publisher: '${businessName}',
  openGraph: {
    title: '${primaryKeyword} | ${businessName}',
    description: '${description.substring(0, 155)}...',
    type: 'website',
    url: '${websiteUrl}/${pageName}',
    siteName: '${businessName}',
    images: [
      {
        url: '${websiteUrl}/og-image.jpg',
        width: 1200,
        height: 630,
        alt: '${primaryKeyword} - ${businessName}',
        type: 'image/jpeg',
      }
    ],
    locale: 'en_US',
  },
  twitter: {
    card: 'summary_large_image',
    title: '${primaryKeyword} | ${businessName}',
    description: '${description.substring(0, 155)}...',
    images: ['${websiteUrl}/twitter-image.jpg'],
    creator: '@${businessName.toLowerCase().replace(/\s+/g, "")}',
    site: '@${businessName.toLowerCase().replace(/\s+/g, "")}',
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  alternates: {
    canonical: '${websiteUrl}/${pageName}',
  },
  category: '${projectInfo.industry || "Business"}',
}`

    const structuredData = `// Add this to your page component
const structuredData = {
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "${primaryKeyword} | ${businessName}",
  "description": "${description}",
  "url": "${websiteUrl}/${pageName}",
  "mainEntity": {
    "@type": "Organization",
    "name": "${businessName}",
    "url": "${websiteUrl}",
    "description": "${description}",
    "keywords": "${keywords.join(", ")}"
  }
}

// Add to your JSX:
<script
  type="application/ld+json"
  dangerouslySetInnerHTML={{ __html: JSON.stringify(structuredData) }}
/>`

    return { metadata, structuredData }
  }

  if (file.type === "jsx") {
    const metadata = `// SEO Metadata - Generated by AxoraWeb SEO Code Generator
export const metadata = {
  title: '${primaryKeyword} | ${businessName}',
  description: '${description.substring(0, 155)}... | ${businessName}',
  keywords: '${keywords.join(", ")}',
  authors: [{ name: '${businessName}' }],
  openGraph: {
    title: '${primaryKeyword} | ${businessName}',
    description: '${description.substring(0, 155)}...',
    type: 'website',
    images: [
      {
        url: '${websiteUrl}/og-image.jpg',
        width: 1200,
        height: 630,
        alt: '${primaryKeyword} - ${businessName}'
      }
    ],
    siteName: '${businessName}',
  },
  twitter: {
    card: 'summary_large_image',
    title: '${primaryKeyword} | ${businessName}',
    description: '${description.substring(0, 155)}...',
    images: ['${websiteUrl}/twitter-image.jpg'],
  },
  alternates: {
    canonical: '${websiteUrl}/${pageName}',
  },
}`

    const htmlHead = `// Add to your JSX head section:
<Head>
  <title>${primaryKeyword} | ${businessName}</title>
  <meta name="description" content="${description.substring(0, 155)}... | ${businessName}" />
  <meta name="keywords" content="${keywords.join(", ")}" />
  <link rel="canonical" href="${websiteUrl}/${pageName}" />
  <meta property="og:title" content="${primaryKeyword} | ${businessName}" />
  <meta property="og:description" content="${description.substring(0, 155)}..." />
  <meta property="og:image" content="${websiteUrl}/og-image.jpg" />
</Head>`

    return { metadata, htmlHead }
  }

  return {}
}

function calculateSEOScore(currentSEO: FileAnalysis["currentSEO"]): number {
  let score = 0
  if (currentSEO.hasTitle) score += 20
  if (currentSEO.hasDescription) score += 25
  if (currentSEO.hasKeywords) score += 15
  if (currentSEO.hasOpenGraph) score += 25
  if (currentSEO.hasStructuredData) score += 15
  return score
}

function generateIssuesAndRecommendations(currentSEO: FileAnalysis["currentSEO"], fileType: string) {
  const issues: string[] = []
  const recommendations: string[] = []

  if (!currentSEO.hasTitle) {
    issues.push("Missing page title")
    recommendations.push("Add a descriptive title with primary keyword")
  }

  if (!currentSEO.hasDescription) {
    issues.push("Missing meta description")
    recommendations.push("Add a compelling meta description (150-160 characters)")
  }

  if (!currentSEO.hasKeywords) {
    issues.push("Missing target keywords")
    recommendations.push("Add relevant keywords for better search visibility")
  }

  if (!currentSEO.hasOpenGraph) {
    issues.push("Missing Open Graph tags")
    recommendations.push("Add Open Graph tags for better social media sharing")
  }

  if (!currentSEO.hasStructuredData) {
    issues.push("Missing structured data")
    recommendations.push("Add JSON-LD structured data for rich snippets")
  }

  return { issues, recommendations }
}

export async function POST(request: NextRequest) {
  try {
    console.log("Project analysis request received")

    const formData = await request.formData()
    const file = formData.get("file") as File
    const projectInfoStr = formData.get("projectInfo") as string

    if (!file) {
      console.error("No file provided in request")
      return NextResponse.json({ error: "No file provided" }, { status: 400 })
    }

    let projectInfo: ProjectInfo
    try {
      projectInfo = JSON.parse(projectInfoStr)
    } catch (e) {
      console.error("Could not parse project info:", e)
      return NextResponse.json({ error: "Invalid project information" }, { status: 400 })
    }

    console.log(`Processing project: ${file.name}, size: ${file.size} bytes`)

    if (!file.name.endsWith(".zip")) {
      console.error("File is not a ZIP file:", file.name)
      return NextResponse.json({ error: "Please upload a ZIP file" }, { status: 400 })
    }

    const arrayBuffer = await file.arrayBuffer()
    console.log("File read successfully, parsing ZIP...")

    let zip: JSZip
    try {
      zip = await JSZip.loadAsync(arrayBuffer)
      console.log("ZIP file parsed successfully")
    } catch (error) {
      console.error("Error parsing ZIP file:", error)
      return NextResponse.json({ error: "Invalid ZIP file format" }, { status: 400 })
    }

    // Detect project type
    const { projectType, framework } = detectProjectType(zip.files)
    console.log(`Detected project type: ${projectType}, framework: ${framework}`)

    const pageFiles: FileAnalysis[] = []
    const componentFiles: FileAnalysis[] = []
    const staticFiles: FileAnalysis[] = []
    let totalFiles = 0

    console.log("Analyzing project files...")

    // Analyze each file in the ZIP
    for (const [filename, zipEntry] of Object.entries(zip.files)) {
      if (zipEntry.dir) {
        console.log(`Skipping directory: ${filename}`)
        continue
      }

      totalFiles++
      const fileType = getFileType(filename)
      const isPage = isPageFile(filename, projectType)
      const isComponent = !isPage && (fileType === "jsx" || fileType === "tsx")

      try {
        console.log(`Analyzing file: ${filename}`)
        const content = await zipEntry.async("string")
        const currentSEO = analyzeCurrentSEO(content, fileType)
        const seoScore = calculateSEOScore(currentSEO)
        const needsSEO = seoScore < 80 && (isPage || isComponent)
        const { issues, recommendations } = generateIssuesAndRecommendations(currentSEO, fileType)

        const fileAnalysis: FileAnalysis = {
          filename,
          path: filename,
          type: fileType,
          size: content.length,
          isPage,
          isComponent,
          needsSEO,
          currentSEO,
          seoCode: needsSEO
            ? generateSEOCode(
                {
                  filename,
                  path: filename,
                  type: fileType,
                  size: content.length,
                  isPage,
                  isComponent,
                  needsSEO,
                  currentSEO,
                  seoCode: {},
                  issues,
                  recommendations,
                  seoScore,
                },
                projectInfo,
              )
            : {},
          issues,
          recommendations,
          seoScore,
        }

        if (isPage) {
          pageFiles.push(fileAnalysis)
        } else if (isComponent) {
          componentFiles.push(fileAnalysis)
        } else {
          staticFiles.push(fileAnalysis)
        }

        console.log(`Analyzed ${filename}: Page=${isPage}, Component=${isComponent}, SEO Score=${seoScore}`)
      } catch (error) {
        console.error(`Error analyzing file ${filename}:`, error)
        // Add the file with error but don't fail the entire process
        staticFiles.push({
          filename,
          path: filename,
          type: fileType,
          size: 0,
          isPage: false,
          isComponent: false,
          needsSEO: false,
          currentSEO: {
            hasTitle: false,
            hasDescription: false,
            hasKeywords: false,
            hasOpenGraph: false,
            hasStructuredData: false,
          },
          seoCode: {},
          issues: [`Error analyzing file: ${error instanceof Error ? error.message : "Unknown error"}`],
          recommendations: [],
          seoScore: 0,
        })
      }
    }

    if (totalFiles === 0) {
      console.error("No files found in ZIP")
      return NextResponse.json({ error: "No files found in the ZIP archive" }, { status: 400 })
    }

    // Calculate overall SEO readiness
    const allAnalyzedFiles = [...pageFiles, ...componentFiles]
    const seoReadiness =
      allAnalyzedFiles.length > 0
        ? Math.round(allAnalyzedFiles.reduce((sum, file) => sum + file.seoScore, 0) / allAnalyzedFiles.length)
        : 0

    const analysis: ProjectAnalysis = {
      projectType,
      framework,
      totalFiles,
      pageFiles,
      componentFiles,
      staticFiles,
      hasRouting: projectType === "nextjs" || projectType === "react",
      hasMetadata: pageFiles.some((f) => f.currentSEO.hasTitle && f.currentSEO.hasDescription),
      seoReadiness,
    }

    console.log(`Analysis complete: ${totalFiles} files, ${pageFiles.length} pages, ${seoReadiness}% SEO ready`)

    return NextResponse.json({
      success: true,
      analysis,
    })
  } catch (error) {
    console.error("Unexpected error in project analysis:", error)
    return NextResponse.json(
      {
        error: "Internal server error during analysis",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    )
  }
}
